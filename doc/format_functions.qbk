[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[import ../example/v0/format_functions.cpp]

[#format_functions]
[section Format functions]

The library provides some functions ( actually function templates ) to be used to
specify formatting. For example, in order to print some integer in hexadecimal,
you can use `hex`:

[trivial_hex_sample]

Actually, `hex` is just a syntactic sugar that that calls `fmt`:

``
template <typename T>
constexpr auto hex(const T& value)
{
    return fmt(value).hex();
}
``

The [*`fmt`] function template returns an object that contains the value to be
printed well as formatting information, which can be changed with the member functions
listed in the table below. All these member functions return `*this`.

The return type of `fmt(arg)` depends on the type of `arg`, which may not contain
some of the member functions below. That's why `hex("blah blah")`,
does not compile, since hexadecimal formatting does not apply to strings.

[table
[[member function] [effect] [input types]]

[
[`operator>(int width)`]
[right adjustment]
[all ( integer, floating point, character, string, `void*`, `bool`) ]
]


[[`operator<(int width)`] [left adjustement] [all]]
[[`operator^(int width)`] [centered adjustment] [all]]
[
[`operator%(int width)`]
[internal adjustment (as in [@http://en.cppreference.com/w/cpp/io/manip/left `std::internal`])]
[integer and floating point]
]
[[`fill(char32_t ch)`][set the fill character to [~ch]] [all]]

[[`dec()`] [decimal base] [integer and floating point]]
[[`hex()`] [hexadecimal base] [integer and floating point]]
[[`oct()`] [octadecimal base] [integer]]
[
[`uppercase(bool b)`]
[if [~b] is `true`, convert some characters to uppercase (as in [@http://en.cppreference.com/w/cpp/io/manip/uppercase `std::uppercase`])]
[integer and floating point]
]

[
[`showpos(bool b)`]
[if [~b] is `true`, print the positive sign for non-negative numbers (as in [@http://en.cppreference.com/w/cpp/io/manip/showpos `std::showpos`])]
[integer and floating point]
]

[
[`showbase(bool b)`]
[if [~b] is `true`, print the numeric base indication (as in [@http://en.cppreference.com/w/cpp/io/manip/showbase `std::showbase`])]
[integer and floating point]
]

[[`operator+()`][same as `showpos(true)`][integer and floating point]]
[[`operator~()`][same as `showbase(true)`][integer]]
[[`multi(int count)`][print the character [~count] times][character]]

]

[h4 Syntatic sugars]

[table Syntatic sugars
[[expression] [equivalent to]]
[[`hex(x)`][`fmt(x).hex()`]]
[[`uphex(x)`][`fmt(x).hex().uppercase(true)`]]
[[`dec(x)`][`fmt(x).dec()`]]
[[`oct(x)`][`fmt(x).oct()`]]
[[`right(x, width)`][`fmt(x) > width`]]
[[`left(x, width)`][`fmt(x) < width`]]
[[`center(x, width)`][`fmt(x) ^ width`]]
[[`internal(x, width)`][`fmt(x) % width`]]
[[`right(x, width, fill)`]   [`fmt(x).fill(fill) > width`]]
[[`left(x, width, fill)`]    [`fmt(x).fill(fill) < width`]]
[[`center(x, width, fill)`]  [`fmt(x).fill(fill) ^ width`]]
[[`internal(x, width, fill)`][`fmt(x).fill(fill) % width`]]
[[`multi(x, count)`] [`fmt(x).multi(count)`]]
]

[/
``
template <typename T> constexpr auto uphex(const T& value)
{
  return fmt(value).uppercase(true).hex();
}
template <typename T> constexpr auto hex(const T& value)
{
    return fmt(value).hex();
}
template <typename T> constexpr auto dec(const T& value)
{
    return fmt(value).dec();
}
template <typename T> constexpr auto oct(const T& value)
{
    return fmt(value).oct();
}
template <typename T> constexpr auto left(const T& value, int width)
{
    return fmt(value) < width;
}
template <typename T> constexpr auto right(const T& value, int width)
{
    return fmt(value) > width;
}
template <typename T> constexpr auto internal(const T& value, int width)
{
    return fmt(value) % width;
}
template <typename T> constexpr auto center(const T& value, int width)
{
    return fmt(value) ^ width;
}
template <typename T> constexpr auto left(const T& value, int width, char32_t fill)
{
    return fmt(value).fill(fill) < width;
}
template <typename T> constexpr auto right(const T& value, int width, char32_t fill)
{
    return fmt(value).fill(fill) > width;
}
template <typename T> constexpr auto internal(const T& value, int width, char32_t fill)
{
    return fmt(value).fill(fill) % width;
}
template <typename T> constexpr auto center(const T& value, int width, char32_t fill)
{
    return fmt(value).fill(fill) ^ width;
}
template <typename T, typename I> constexpr auto multi(const T& value, I count)
{
    return fmt(value).multi(count);
}
``
]
[h4 Example]

[formatting_samples]

[endsect]