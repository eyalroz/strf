[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[import ../example/v0/trivial_sample.cpp]
[import ../example/v0/syntax_samples.cpp]
[section Syntax]

[/ Railroad diagram generated from the EBNF below, in online generator bottlecaps.de/rr

  usage ::= 'leading_expression'
  ( '()' | '.no_reserve()' | '.reserve(size)' | '.reserve_auto()' | '.with(facets...)' ) *
  ( '[assembly_string]' ? ('={arguments...}' | '&={arguments...}'))
]

[#syntax_diagram]

[$../usage.png]
[footnote This railroad diagram was generated on [@http://bottlecaps.de/rr bottlecaps.de/rr]]

The ['[*leading expression]] is the part of the expression the varies according to the output type, as show in [link output_types.output_types this table].

The [link section_assembly_string ['[*assembly string]]] is analogous to what in others format libraries is called as the /format string/, except that it does not format any of the arguments. Formatting is specified instead with [link format_functions format functions].

Example:

[trivial_sample]

In order to reduce code bloat and increase perfomance, it is recomended to use the assembly string if it reduces the number of arguments.

[h3 Arguments]

The "conventional" input types are ( or will be ) supported:

* an integer ( `int, long, long long, unsigned int, unsigned long or unsigned long long`)
* a string ( a raw string or a `std::basic_string` or `std::basic_string_view`)
* a single character
* a boolean ['( todo )]
* a void pointer ['( todo )]
* a floating point ['( todo )]

In addition to those, there are also some "special" input types, that are explained in another section.

As shown in the diagram, there two diferent ways you can inject the arguments:

[#syntax_args_form2]
[variablelist     
[[ \u2022 /leading_expression/  \u00b7\u00b7\u00b7 ` = {`[~args ...]`}`]
 [This expression call and returns the return the [link OutputWriterConcept `finish()`] member function of the writer object. This varies according to the leading expressiong as described [link ReturnTypes here], but should be `std::error_code` or some type that contains an `std::error_code` ( like __STD_EXPECTED__`<some_type, std::error_code>` )]
]
]

[#syntax_args_form3]
[variablelist
[[ \u2022 /leading_expression/  \u00b7\u00b7\u00b7 ` &= {`[~args ...]`}`]
 [This form use exceptions instead of error codes. It calls and returns the return of [link OutputWriterConcept `finish_throw()`] instead of `finish()`. So instead of returning an `std::error_code` ( or an object that contains an `std::error_code` ) it throws an exception createad from such `std::error_code`, if such `std::error_code` is not empty. The return types are listed [link ReturnTypes_throw here].
]

]
]

[note Although the two former forms ( /leading_expression/  \u00b7\u00b7\u00b7  `({`[~args ...]`})` and /leading_expression/  \u00b7\u00b7\u00b7  ` = {`[~args ...]`}` ) are based on error code, this does not mean they never throw, /i.e./ eventual exceptions are [_not] intercepted. Although the library's code does not throw anywhere ( except in [link OutputWriterConcept `finish_throw()`] definitions ), exceptions may still come from user extensions or from the destination object. For example, the expression `append_to(destination_str) = {`[~args ...]`}` may throw an `std::bad_alloc` originated from `destination_str`.]

In some cases the /leading expression/ is not assignable. This is the case of `make_string` which is a `constexpr`, for example. But you can get an assignable expressing from it by simply calling `operator()()`, or any of others member functions ( `with()`, `reserve()`, `reserve(std::size_t)` or `no_reserve()` ):
[make_string_is_not_assignable]

[#syntax_reserve]
[h3 Reserving output size]

The following member functions only have effect in some output types ( cases 1 to 7 in [link output_types.output_types this table], or when you create the [link OutputWriterConcept reserve] method when defining your own ouput type ). 

* [*`reserve_auto()`] : The necessary amount of characters is calculated and reserved in the destination object. This is the default.
* [*`reserve(std::size_t size)`] : The calculation is skipped and the specified `size` is used instead.
* [*`no_reserve()`] : No reservation is done.

[syntax_reserve]


[endsect]

