[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[import ../example/v0/decoding_facets.cpp]
[import ../example/v0/custom_decoding_error_handling.cpp]
[import ../example/v0/custom_decoder.cpp]

[#decoder_facet]
[section  Decoding UTF-8]

[h4 The [^u8decoder] class template]

An instance of the `u8decoder` class template is a facet that decodes UTF-8.

``
template <typename F>
// requires requires(F func, u32output& out) { { func(out) } -> bool; }
class u8decoder: public decoder<char>
{
public:
    u8decoder(F error_handling_function);
    u8decoder(const u8decoder&);
    u8decoder(u8decoder&&);
    ~u8decoder();

    u8decoder&  tolerate_overlong(bool _ = true) &;
    u8decoder&& tolerate_overlong(bool _ = true) &&;
    u8decoder   tolerate_overlong(bool _ = true) const &;

    u8decoder&  mutf8(bool _ = true) &;
    u8decoder&& mutf8(bool _ = true) &&;
    u8decoder   mutf8(bool _ = true) const &;

    u8decoder&  wtf8(bool _ = true) &;
    u8decoder&& wtf8(bool _ = true) &&;
    u8decoder   wtf8(bool _ = true) const &;

    void decode(u32output& dest, const char* begin, const char* end) const override;
};
``
The `error_handling_function` argument passed in the constructor is a function object that is called by the `decode` function when an invalid byte sequence is found in the input string. What is considered to be an invalid byte sequence can be configured with the following member functions:

* `tolerate_overlong` \u2014 Allow [@https://en.wikipedia.org/wiki/UTF-8#Overlong_encodings overlong byte sequences].
* `mutf8` \u2014 Allow the byte sequence `"\xC0\x80"` as valid, converting it to `U'\0'`.
* `wtf8` \u2014 Allow the encodings of the surrogates halves.

[h4 Helper functions]

The library provides two helper functions to instantiate UTF-8 decoding facets:
``
auto make_u8decoder() -> u8decoder<bool(*)(u32output&)>;
``
``
template <typename F>
 // requires requires(F func, u32output& out) { { func(out) } -> bool; }
auto make_u8decoder(F error_handling_funcion) -> u8decoder<F>;
``
When `make_u8decoder()` is used ( without any argument ) the decoder is initialized with an error handling function that replaces each invalid sequence by a replacement character "\uFFFD" ( `U'\uFFFD'` ). 

[h4 Example]

[utf8_decoding_options]

[endsect]
[section Decoding UTF-16]

The library provides two UTF-16 decoders: The `u16decoder` and `lax_u16decoder` class templates.

[h4 The [^u16decoder] class template]

``
template <typename CharT, typename F>
// requires requires(F func, u32output& out) {{func(out)} -> bool;};
class u16decoder: public decoder<CharT>
{
public:
    u16decoder(F error_handling_function);
    u16decoder(const u16decoder&);
    u16decoder(u16decoder&&);
    ~u16decoder();

    void decode(u32output& dest, const CharT* begin, const CharT* end) const override;
}
``

An instance of the `u16decoder` class template is a facet that decodes UTF-16. It considers an error when a high surrogate is not followed by a low surrogate, as well as when a low surragate is not preceded by a high surrogate. When this happens, it calls the error handling function object defined in its construction. 

[h4 The [^lax_u16decoder] class template]

The `lax_u16decoder` on the other hand never considers the input as invalid. If a high surrogate is not followed by a low surrogate, then it simply produces a `char32_t` with the same value, even if this is considered an illegal code point. The same happens when a low surragate is not preceded by a high surrogate.

``
template <typename CharT>
class lax_u16decoder: public decoder<CharT>
{
public:
    lax_u16decoder(const u16decoder&);
    lax_u16decoder(u16decoder&&);
    ~lax_u16decoder();

    void decode(u32output& dest, const CharT* begin, const CharT* end) const override;
}
``
[h4 Helper functions]

The library provides the following helper function templates to instatiate UTF-16 decoders:
``
// Creates a u16decoder with the default error handler
template <typename CharT>
u16decoder<bool(*)(u32output&)> make_u16decoder();
``
``
template <typename CharT, typename F>
// requires requires(F func, u32output& out) {{func(out)} -> bool;};
u16decoder<F> make_u16decoder(F error_handling_funcion);
``
``
/* implementation defined */ make_lax_u16decoders();
``
``
/* implementation defined */ make_u16decoders();
``
``
template <typename F>
// requires requires(F func, u32output& out) {{func(out)} -> bool;};
/* implementation defined */ make_u16decoders(F error_handling_function);
``

Note that the name of the three later are in plural (...[^decoder[*s]]). The return type of these depends on `sizeof(wchar_t)`. If it `sizeof(wchar_t) == 2` and `BOOST_STRINGIFY_DONT_ASSUME_WCHAR_ENCODING` macro is not defined, then the return is an `ftuple` containing two decoders, one for `char16_t` a another for `wchar_t`.

When `make_u16decoders()` or `make_u16decoder()` is used ( without argument ) the error handling is to replace each invalid sequence by the replacement character "\uFFFD" ( `U'\uFFFD'` ).

[endsect]
[section Customizing the decoder error handling function]

As already mentioned, the default error handling is to translate the invalid sequence by a
"\uFFFD" character ( `U'\uFFFD'` ). However you can write and error handler that behaves differently.
The error handler of a
[@http://en.cppreference.com/w/cpp/concept/CopyConstructible CopyConstructible]
and [@http://en.cppreference.com/w/cpp/concept/Callable Callable] type.
It receives a [link u32output `u32output&`] as paramenter and returns a `bool`.
When `false` is returned, the `decode` member function of the decoder returns immediately,
otherwise it continues to process the remaining input.

If you want an error handler that

* replaces the invalid input sequence by some other character, then write a handler that calls [link u32output `u32output`]`::put` and returns `true`.
* that causes a certain `std::error_code` to be returned, then write a handler that calls [link u32output `u32output`]`::set_error` and returns `false`.
* thats throws an exception, then write a handler that throws such exception.

[h4 Example]

[custom_decoding_error_handling]

[endsect]
[section How to implement your own decoder]

You need to create a non abstract, [@http://en.cppreference.com/w/cpp/concept/CopyConstructible CopyConstructible] class that inherits from [^decoder<][~CharT][^>], where [~CharT] is `char`, `wchar_t`, `char16_t` or `char32_t`.


[h4 The [^decoder] class template]
``
template <typename CharT> class decoder
{
public:

    using category = decoder_tag<CharT>;

    virtual ~decoder();

    virtual void decode
        ( u32output& destinaion
        , const CharT* begin
        , const CharT* end
        ) const = 0;
};
``

The [*`decode`] member function shall reads the string contained in `[begin, end)`, and calls `u32output::put` for each code point.

[#u32output]
[h4 The [^u32output] class]
``
class u32output
{
public:

    virtual ~u32output();

    virtual bool put(char32_t ch) = 0;

    virtual void set_error(std::error_code err) = 0;
};
``

[h4 Example]

[custom_decoder]

[/


``
template <typename F>
concept DecoderErrHandlingFunc
    = std::CopyConstructable
   && requires(F f, stringify::u32output& out) { {f(out)} -> bool; }

template <DecoderErrHandlingFunc ErrHandlingFunc> class u8decoder;
``
[h4 Member functions]

* `tolerate_overlong`
* `mutf8` 
* `wtf8`

[h4 ]

* `make_u8decoder()`
* `make_u8decoder(err_func)`



[h4 Requirements]
``
    template <typename T, typename CharT>
    concept Decoder
        = std::CopyConstructable<T>
       && std::Destructable<T>;
       && std::is_base_of<T, stringify::decoder<CharT>>::value;
``
the `decoder` class template is defined as:

[decoder_class_template]

]

[endsect]
