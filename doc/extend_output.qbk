[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[#extend_output]
[section How to add a new destination type]

You can extend the library so that it writes content into a destination other than
[link output_types those] currently supported. That envolves two steps:

[ordered_list
 [Create a class that satisfies the [link OutputBuffer OutputBuffer] requirements]
 [Define an expression (usually a function call) that creates a [link dispatcher dispather]
  based on that class]]

[h3 Example: append to a QString]
[import ../example/appendQString.cpp]

The library provides the [link output_types `append`] function template that enables
you append the output to a `std::string`. Suppose we want to append
instead to a `QString` (from the Qt Framework).
As mentioned, the first thing to do is to create a class that satisfies the
[link OutputBuffer OutputBuffer] concept. Let's name it `QStringAppender`.

The first requirement is that it has to derive from __basic_outbuf__`<CharT>`,
where `CharT` can't be `QChar`,
which is the character type `QString`. It has to be one of the
C++ characters types. So `char16_t` will do the job.

[QStringAppender_def]

The __basic_outbuf__ is initialized with a buffer where the library will
write the content.

[QStringAppender_ctor]

Each time the buffer becomes full, the library calls `recycle`,
that shall consume the content and provide a new buffer ( using
`set_pos` and `set_end` ), whose available
space must be at least __boost_min_size_after_recycle__`<char16_t>`.

[QStringAppender_recycle]

After there is no more content to write, the library calls `finish()`
which must check whether there is anything in the buffer to consume.
It is not necessary for `finish` to return anything. But we will
return the number of characters written.

[QStringAppender_finish]

The last member function that needs to be explained is `reserve`.
Differently from the other three, this one is optional and the library only
calls it once and before the any call to `recycle` in this object, and only
when [link overview_reserve reserve_calc] or [link overview_reserve reserve]
is called in the main [link usage_syntax usage syntax].
The parameter of `reserve` tells how many characters will be written,
so that you can pre-allocate enough memory.
Its value may actually be bigger than necessary, but should never be smaller.

[QStringAppender_reserve]

Now that we have our [link OutputBuffer OutputBuffer],
the next step is to define our global `append` function.
This is where we use the [link dispatcher dispatcher] class template,
whose purpose is to basically to conceive the
[link usage_syntax basic usage syntax] of the library.
Its first template parameter must be an instance of the __facets_pack__
template, and almost aways is __facets_pack__`<>`.
The sencond parameter is our [link OutputBuffer OutputBuffer]:
the `QStringAppender` class. The remaining template parameters
are the types of the elements that are stored inside the dispatcher
object and are used by the [link dispatcher_strf stringification functions]
to initialize the [link OutputBuffer OutputBuffer] (`QStringAppender`) object.
The `dispatcher` constructor initializes such elements with the arguments
it receives:


[QStringAppender_dispatcher]

And it's done:

[QStringAppender_use]

[h3 Other examples]

* [@../../example/toQString.cpp toQString.cpp]: This file implements `toQString`, which is an equivalent to `to_string` that creates an QString instead.

You can also see how the [link output_types output types] currently supported by the library are implemented:

[itemized_list
  [ [@../../include/boost/stringify/v0/detail/output_types/std_string.hpp
    std_string.hpp] : This is the source file that implements `append`,
    `assign`, `to_string`, `to_u16string`, `to_u32string`,
    `to_wstring` and `to_basic_string`.]
  [ [@../../include/boost/stringify/v0/detail/output_types/char_ptr.hpp
    char_ptr.hpp] : This is the source file implements the `write` and
    `ec_write` function templates that write to raw strings.]
  [ [@../../include/boost/stringify/v0/detail/output_types/std_streambuf.hpp
    std_streambuf.hpp] : This is the source file that implements the `write`
    and `ec_write` function templates that writes to `std::streambuff`.]
  [ [@../../include/boost/stringify/v0/detail/output_types/FILE.hpp FILE.hpp]
    : This is the source file that implements the `write`, `wwrite`, `ec_write`
    and  `ec_wwrite` function templates that writes to `FILE*`.]]

[endsect]