[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section:extend_output How to add support to a new destination type]

Suppose you have a type `foobar` and you want to create a function named `write_to` that takes a `foobar&` as a parameter and can be used just like the [link output_types.output_types other functions]

[#OutputWriterConcept]
[*Step 1)] Create a class - let's call it `foobar_writer` - that satisfies the following requirements:

* inherits from [link output_writer `output_writer<`[~CharT]`>`], where [~CharT] is `char`, `char16_t`, `char32_t` or `wchar_t` ( or rather, make `foobar_writer` a class template ).
* is not abstract.
* has a [*`finish()`] public member function. This function will be called just before `foobar_writer` is destroyed when the expression [link syntax_args_form2 `write_to(foobar_instance) = {args...}`] is used. By convention, it should return an `std::error_code` or an object that contains an `std::error_code` ( like an __STD_EXPECTED__ )
* has a [*`finish_throw()`] public member function. This function will be called just before `foobar_writer` is destroyed when the expression [link syntax_args_form3 `write_to(foobar_instance) &= {args...}`] is used. By conventions, instead of returning an `std::error_code` or object that contains an `std::error_code` ( like `finish()` does), this function should throw an exception created from such `std::error_code`.
* [#OutputWriter_reserve] [_optionally], it may contain a [*`reserve(std::size_t size)`] public member function. If present, this function is called (or not) according to the use of [link syntax_reserve `reserve_auto()`, `reserve()` or `no_reseve()`] in the [link syntax_diagram basic invocation syntax]. The parameter `size` tells how many characters will be written. This function will be called no more than once, and only before any of the writing functions ([link output_writer `put`] and [link output_writer `repeat`]). The argument will be the total number of chararacters that will be written until `finish()` of `finish_throw()` is called.

[*Step 2)] Implement function `write_to` ( or whatever name you prefer ) like below:

```
  auto write_to(foobar& destination)
  {
     return boost::stringify::make_args_handler<foobar_writer, foobar&>(destination);
  }
```
The argument(s) passed to function template `make_args_handler` will be used to construct `foobar_writer`. Its signature is:

```
template <typename OutputWriter, typename ... Args>
constexpr auto make_args_handler(Args ... args) -> /* implementation_defined */;
```
[important Note that the parameters list of `make_args_handler` is `(Args ... arg)` and [_not] `(Args `[*`&&`]` ... args)`. Hence, if you want to pass a paramenter by reference, template type deduction won't do what you want. You must specify the type of each argument, as done in the example above ]



[/
Given 

* `W`, a type that satisfies `OutputWriter` concept
* `w`, an object of type `W`
* `ch`, a value of type `W::char_type`
* `str`, a pointer of `W::char_type`
* `i`, `n`, values of type `std::size_t`

[table
[ [Expression]       [Return type] [Description] ]
[ [`W::char_type`]   []      [The character type (`char`, `wchar_t`, `char32_t` or `char16_t`)] ]
[ [`w.finish()`]     [anything] [ Finalizes the writing process. This funcion is called at the end. ]]
]
]

[h3 The `output_writer` class template]

[#output_writer]
``
template <typename CharT>
class output_writer
{
public:

    using char_type = CharT;

    virtual ~output_writer();

    virtual void set_error(std::error_code err) = 0;

    virtual bool good() const = 0;

    virtual bool put(const CharT* str, std::size_t size) = 0;

    virtual bool put(CharT ch) = 0;

    virtual bool repeat(std::size_t count, CharT ch) = 0;

    virtual bool repeat(std::size_t count, CharT ch1, CharT ch2) = 0;

    virtual bool repeat(std::size_t count, CharT ch1, CharT ch2, CharT ch3) = 0;

    virtual bool repeat(std::size_t count, CharT ch1, CharT ch2, CharT ch3, CharT ch4) = 0;
};

``

* The `repeat` function shall attempt to write [~count] times the sequence of character [~ch1], [~ch2], ... , and return `true` on success and `false` on failure.

* `put(CharT ch)` shall attempt to write the character [~ch] and return `true` on success and `false` on failure.

* `put(const CharT* str, std::size_t size)` shall attempt to write [~size] chararacter of [~str], /i.e./ the range `[str[0], str[size])`, and return `true` on success and `false` on failure.

*  Once the function `set_error` is called, `good()` shall return `false` and all the writting functions (`put` and `repeat`) shall have no effect and return `false`.

*  `good()` returns whether this `output_writer` instance is capable of writing more characters ( through the `put` and `repeat` functions ). Once `good()` returns false, it shall not return `true` anymore, and all the writting functions (`put` and `repeat`) shall have no effect and return `false`.

[h3 Examples]

You can read how the [link output_types.output_types already supported output types] are implemented:

* [@../../include/boost/stringify/v0/output_types/std_string.hpp    std_string.hpp] : This is the source file that implements the [*`append_to`] and [*`assign_to`] funcion templates.
* [@../../include/boost/stringify/v0/output_types/make_string.hpp   make_string.hpp] : This is the source file implements the [*`make_string`], [*`make_u16string`], [*`make_u32string`], [*`make_wstring`] and [*`make_basic_string`] funcion templates.
* [@../../include/boost/stringify/v0/output_types/char_ptr.hpp char_ptr.hpp] : This is the source file implements the [*`write_to`] funcion templates that write to raw strings.
* [@../../include/boost/stringify/v0/output_types/std_streambuf.hpp std_streambuf.hpp] : This is the source file that implements the [*`write_to`] funcion template that writes to `std::streambuff`.
* [@../../include/boost/stringify/v0/output_types/FILE.hpp FILE.hpp] : This is the source file that implements the [*`write_to`] and [*`wwrite_to`] funcion templates that writes to `FILE*`.

[endsect]