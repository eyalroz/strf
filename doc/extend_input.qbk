[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]


[section:extend_input How to add a new input type]

[/
Probably you only need to read the first example to know how to add most the input types you desire. There, we a print a IPv4 address, which is very simple since it is always four integer numbers separated by dots. Of course, there is no need to determinate each digit of the each of these numbers, since we use the library to print the numbers.
]

[variablelist
  [ [ Step 1]
    [ Overload `make_printer` function template like this:
      ``
      template <typename CharT, typename FacetsPack>
      printer_type make_printer( const FacetsPack fp&
                               , your_input_type );
      ``
      where
      [itemized_list
        [ `CharT` is the output character type. ]
        [ `FacetsPack` is always an instance of [link facets_pack facets_pack] class template ]
        [ `printer_type` must be a concrete move-constructible type that inherits from
          [link printer `printer`]`<CharT>`. So actually there is still a previous step which
          is to define `printer_type`. However in the most simple ( and probably common )
          case this is unnecessary, because you can just return a call to another overload
          of `make_printer`. ]
      ] [/itemized_list]
    ]
  ] [/end step 1]
  [ [Step 2]
    [ [_If] you want to provide formatting options for this new type,
      then use the [link value_with_format `value_with_format`] class template to define
      another input type that contains both the input value and the format functions.
      ``
      using your_input_type_with_format = boost::stringify::value_with_format< your_input_type
                                                                             , format_classes ... >;
      ``
      Then overload the `make_fmt` function like this:
      ``
      your_input_type_with_format make_fmt(boost::stringify::tag, your_input_type);
      ``
    ]
    [ [br] And define another overload of `make_printer` that takes `your_input_type_with_format`
      ``
      template <typename CharT, typename FacetsPack>
      printer_type_2 make_printer( const FacetsPack fp&
                                 , your_input_type_with_format );
      ``
    ]
  ] [/ end step 2]
] [/ end of variable_list ]

[#ipv4_example]
[section:ipv4_example Example 1: IPv4 address]
[import ../example/extend_input_ipv4.cpp]

Suppose `ipv4address` below is the input type:

[ipv4address_type]

Here, we can simply create a [link joins join] and return the result of calling
`make_printer` over it:

[make_printer_ipv4address]

And it's done:

[ipv4_basic_sample]

[warning Watch out for dangling references: the expression
`join(/*...*/) (arg1, arg2, arg3)` instantiates an object
that holds [_references] to `arg1`, `arg2` and `arg3`,
which are commonly temporaries.
The following code has undefined behavior:
``
  j = strf::join()(123); // a temporary int created here
  return make_printer(out, fp, j); // j holds a dangling reference
``
]

[h4 Adding alignment formatting options]

Now let's go further and enable alignment, /a.k.a./ justification.
First, we use the [link value_with_format `value_with_format`] class template to define another input type that contains both an `ipv4address` value as well as the formatting stuff:

[ipv4address_with_format]

Now we define an overload of `make_printer` for `ipv4address_with_format`.

[make_printer_fmt_ipv4]

And it's done:

[formatted_ipv4address]

[note You may be wondering whether it is necessary to use
`value_with_format` template to implement `ipv4address_with_format`.
After all it seems that all we need is any type that contains both
the value ( the IP address ) and the formatting stuff.
However if you want it to work in [link ranges fmt_range], then
it has to be `value_with_format`.
[formatted_ipv4address_in_ranges]
]

[endsect]

[section Example 2: IPv6 address]
[import ../example/extend_input_ipv6.cpp]

Now our input type represents an [@https://en.wikipedia.org/wiki/IPv6_address IPv6 address]:

[ipv6address]


[h4 Creating new format functions]

An IPv6 address can be represented in different ways. For example the three
representations below are equivalent:

* 2001:db8:0000:0000:0000:0000:0000:0001
* 2001:db8:0:0:0:0:0:1
* 2001:db8::1

So let's create the format functions named `big()` and `small()`
to select the longest and shortest representation respectively,
leaving the intermediate one as the default.

[ipv6_format]

[/
[note Notice that `big()` and `small()` are declared with the rvalue ref-qualifier
( the token '&&' after the parameter list ) and return `*this` as `derived_type &&`.
This is the convention for format functions. It is what allows constructions
like `hex(200).showbase().fill(U'.') > 20`]
]

Now we define a class that gathers the IPv6 address value
with the formatting information and then we define the `make_fmt` function.
In addition to the formatting option that enables the abbreviated
representation, let's add support to alignment formatting, just
as we did in the [link ipv4_example IPv4 example].

[ipv6addr_with_format]

[#dynamic_join_printer]
[h4 The `dynamic_join_printer` class template]

It is not possible to simply use a [link joins join] as we did in the
[link ipv4_example IPv4 example] when the elements that composes the
[link joins join] are not known at compilation time.

Fortunately, the library provides an alternative solution
for cases like that: the `dynamic_join_printer`
class template.

``
template <typename CharOut>
class dynamic_join_printer: public stringify::v0::printer<CharOut>
{
public:

    dynamic_join_printer(stringify::v0::output_writer<CharOut>& out);

    void write() const override;
    std::size_t necessary_size() const override;
    int width(int limit) const override;

protected:

    virtual void compose(stringify::v0::printers_receiver<CharOut>& out) const = 0;

    virtual stringify::v0::alignment_format<void> formatting() const
    {
        return {}; // by default the width is zero
    }
};
``

The `printers_receiver` class template is simply:
``
template <typename CharOut>
class printers_receiver
{
public:

    virtual ~printers_receiver();

    virtual void put(const stringify::v0::printer<CharOut>& ) = 0;
};
``
[/
When the `put` member function returns `false` there is no point
in calling it again with the remaining printers. This does not
necessarily mean that an error happened.
]
[/
For example, the implementation of `width`
creates a `printer_receivers` whose `put` function
returns false when the width is greater or equal to `limit`.
]

[h4 The printer]

We create a class template the derives from
[link dynamic_join_printer dynamic_join_printer]

[ipv6_printer]

The constructor:
[ipv6_printer__contructor]

[caution The `facets_pack` object that is passed in the constructor of a
printer class may be a temporary object. Hence don't store a reference
to it as a member variable of the printer class. It may became dangling. ]

And the `compose` function:

[ipv6_printer__compose]

And we need to override the `formatting()` function:

[ipv6_printer__formatting]

Now we just need to overload `make_printer`

[ipv6__make_printer]

And it's done:

[ipv6_samples]

You can see the full source code of the implementation [@../../example/extend_input_ipv6.cpp here].

[endsect]

[#base64_example]
[section Example 3: Base64]
[import ../example/extend_input_base64.cpp]

[/
It's like we wanted to create a function that takes an array of bytes and encodes it in
[@https://en.wikipedia.org/wiki/Base64 Base64].
But we rather create an extension to Boost.Stringify,
[/taking thus advantage of the support the library provides for a wide range of output types.]
taking thus advantage of the wide range of output types supported by the library.
Because otherwise we would need a create one function for each output type.
]

Suppose you wanted to implement a [@https://en.wikipedia.org/wiki/Base64 Base64] encoder.
The usual approach is create function like this:
``
std::string to_base_64(const void* data, std::size_t data_size);
``
However, you may soon face the discord the potential users.
Some would say that the output should be a `char*`, while other would disagree.
Some would request a version in `wchar_t`, and perhaps also in `char16_t` and `char32_t`.
So instead of a standalone function, you can implement an extension of Boost.Stringify:
``
boost::stringify::write(destination) (xxx::base64(bytes_array, num_bytes));
``
This way you support several destination and character types with
only one implementation. And everybody is happy, hopefully.

So in this example we are not exactlly adding support to a certain input type.
But we will create one, since we need it to overload `make_printer`:

[fmt_base64_input]

[h4 Creating a new facet category]

Wikipedia told me that there are different
[@https://en.wikipedia.org/wiki/Base64#Variants_summary_table variants]
of Base64. So let's define a new facet category to handle the diversity:

[base64_facet]

[h4 Format function]

Let's also enable the user to specify indentation, which could be
useful when the content is printed into XML or YAML files.
We could have added this option in the facet. But instead
let's create a format function, to make the example more complete.

[base64_format]

Since Base64 content is commonly printed in multiple lines,
alignment formatting doesn't make much sense here. So let's only use
`base64_format` in [link value_with_format `value_with_format`] this time:

[base64_input_with_format]

[h4 Implementing the printer]

``
namespace strf = boost::stringify::v0;

namespace xxx {

template <typename CharT>
class base64_printer: public strf::printer<CharT>
{
public:

    base64_printer( base64_facet facet
                  , const fmt_base64& fmt )
        : _facet(facet), _fmt(fmt)
    {
    }

    bool write(strf::basic_outbuf<CharT>& ob) const override;
    std::size_t necessary_size() const override;
    int width(int) const override;

private:

    /* ... helper functions ... */

    const base64_facet _facet;
    const fmt_base64 _fmt;
};

} // namespace xxx
``
This is an example of a low level implementation.
Differently from the previous ones, here we 
write each individual character directly into
`basic_outbuf<CharT>::pos()`. So the code
is naturally bigger.

[base64_printer__write]

The implementation of `_write_multiline` is omitted for being too large.
You can check it out [@ ../../example/extend_input_base64.cpp here].
But the snippet above convey the idea: you write things in
`basic_outbuf<CharT>::pos()`, but before that, you check how much
available space is there. If it is not sufficient, then you call `recycle`
which resets `pos()` and `end()` providing an a space of at least
__boost_min_size_after_recycle__`<CharT>()`. You can call `recycle`
how many times it is necessary to put all the content.

Now, after defining `base64_printer`, we can finally overload `make_printer`:

[make_printer_base64]

And it's done:

[base64_sample]



[endsect]

[endsect]

